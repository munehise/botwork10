//@version=5
strategy("ADX + Filters Strategy with MA Exits", shorttitle="ADX MA Strategy", overlay=true)

// Helper Functions
f_tma(src, len) =>
    half_len = math.round(len / 2)
    ta.sma(ta.sma(src, half_len), half_len)

f_dema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    2 * ema1 - ema2

f_tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    3 * ema1 - 3 * ema2 + ema3

f_ma(src, len, typ) =>
    switch typ
        "SMA" => ta.sma(src, len)
        "EMA" => ta.ema(src, len)
        "WMA" => ta.wma(src, len)
        "RMA" => ta.rma(src, len)
        "VWMA" => ta.vwma(src, len)
        "TEMA" => f_tema(src, len)
        "HMA" => ta.hma(src, len)
        "TMA" => f_tma(src, len)
        "DEMA" => f_dema(src, len)
        => na

// Main MA Crossover Filter Inputs
useMACrossoverFilter = input.bool(true, title="Use MA Crossover Filter")
fastType = input.string("EMA", title="Fast MA Type", options=["SMA", "EMA", "WMA", "RMA", "TMA", "TEMA", "DEMA", "HMA", "VWMA"])
fastLength = input.int(9, title="Fast MA Length", minval=1)
fastSource = input.source(close, title="Fast MA Source")
slowType = input.string("EMA", title="Slow MA Type", options=["SMA", "EMA", "WMA", "RMA", "TMA", "TEMA", "DEMA", "HMA", "VWMA"])
slowLength = input.int(21, title="Slow MA Length", minval=1)
slowSource = input.source(close, title="Slow MA Source")

// Additional MA Filter Inputs
useMA1Filter = input.bool(false, title="Use MA1 Filter")
ma1Type = input.string("SMA", title="MA1 Type", options=["SMA", "EMA", "WMA", "RMA", "TMA", "TEMA", "DEMA", "HMA", "VWMA"])
ma1Length = input.int(50, title="MA1 Length", minval=1)
ma1Source = input.source(close, title="MA1 Source")
useMA2Filter = input.bool(false, title="Use MA2 Filter")
ma2Type = input.string("EMA", title="MA2 Type", options=["SMA", "EMA", "WMA", "RMA", "TMA", "TEMA", "DEMA", "HMA", "VWMA"])
ma2Length = input.int(200, title="MA2 Length", minval=1)
ma2Source = input.source(close, title="MA2 Source")

// Main ADX Inputs
adxLength = input.int(14, title="ADX Length", minval=1)
adxThreshold = input.int(25, title="ADX Threshold", minval=1)

// Stop Loss Inputs
useStopLoss = input.bool(false, title="Use Stop Loss")
useTrailingSL = input.bool(false, title="Use Trailing SL to ADX Signals")
useRatchetingSL = input.bool(false, title="Use Ratcheting SL (Only Move Forward, Active Additional Exit)")
stopLossOffset = input.float(0.0, title="Stop Loss Offset (Price Units)", minval=0.0)

// Current SL levels (for trading main SL)
var float currentLongSL = na
var float currentShortSL = na

// Current Ratcheting SL levels (for additional active exit)
var float currentRatchetingLongSL = na
var float currentRatchetingShortSL = na

// Calculate Main MAs
fastMA = f_ma(fastSource, fastLength, fastType)
slowMA = f_ma(slowSource, slowLength, slowType)

// Calculate Additional MAs
ma1 = f_ma(ma1Source, ma1Length, ma1Type)
ma2 = f_ma(ma2Source, ma2Length, ma2Type)

// Calculate ADX and DMI
[diplus, diminus, adx] = ta.dmi(adxLength, adxLength)

// Plot Main MAs if filter is used
plot(useMACrossoverFilter ? fastMA : na, color=color.blue, title="Fast MA")
plot(useMACrossoverFilter ? slowMA : na, color=color.orange, title="Slow MA")

// Plot Additional MAs if respective filter is used
plot(useMA1Filter ? ma1 : na, color=color.purple, title="MA1", linewidth=2)
plot(useMA2Filter ? ma2 : na, color=color.aqua, title="MA2", linewidth=2)

// Signal conditions
trendUp = diplus > diminus
trendDown = diminus > diplus
strongTrend = adx > adxThreshold
maCrossoverBullish = useMACrossoverFilter ? fastMA > slowMA : true
maCrossoverBearish = useMACrossoverFilter ? fastMA < slowMA : true
maBullish = (not useMA1Filter or close > ma1) and (not useMA2Filter or close > ma2)
maBearish = (not useMA1Filter or close < ma1) and (not useMA2Filter or close < ma2)

// Buy/Sell signals with filters
buySignal = ta.crossover(diplus, diminus) and strongTrend and maCrossoverBullish and maBullish
sellSignal = ta.crossunder(diplus, diminus) and strongTrend and maCrossoverBearish and maBearish

// New entry conditions (only when flat or reversing)
longEntry = buySignal and strategy.position_size[1] <= 0
shortEntry = sellSignal and strategy.position_size[1] >= 0

// Reset SLs on close or reverse (immediate on change bar)
posChanged = strategy.position_size != strategy.position_size[1]
if posChanged
    if strategy.position_size == 0
        currentLongSL := na
        currentShortSL := na
        currentRatchetingLongSL := na
        currentRatchetingShortSL := na
    else if strategy.position_size > 0 and strategy.position_size[1] <= 0
        currentShortSL := na
        currentRatchetingShortSL := na
    else if strategy.position_size < 0 and strategy.position_size[1] >= 0
        currentLongSL := na
        currentRatchetingLongSL := na

// Force na when no position (every bar)
if strategy.position_size == 0
    currentLongSL := na
    currentShortSL := na
    currentRatchetingLongSL := na
    currentRatchetingShortSL := na

// Strategy entries (always on new entry)
if longEntry
    strategy.entry("Long", strategy.long)
    sl_price = low - stopLossOffset
    if useRatchetingSL
        currentRatchetingLongSL := sl_price
        strategy.exit("Ratcheting Long SL", "Long", stop=sl_price)
        // Disable main SL when ratcheting has priority
        currentLongSL := na
    else if useStopLoss
        currentLongSL := sl_price
        strategy.exit("Main Long SL", "Long", stop=sl_price)

if shortEntry
    strategy.entry("Short", strategy.short)
    sl_price = high + stopLossOffset
    if useRatchetingSL
        currentRatchetingShortSL := sl_price
        strategy.exit("Ratcheting Short SL", "Short", stop=sl_price)
        // Disable main SL when ratcheting has priority
        currentShortSL := na
    else if useStopLoss
        currentShortSL := sl_price
        strategy.exit("Main Short SL", "Short", stop=sl_price)

// Trailing SL updates (if enabled, update on every signal in direction, affects main trade SL)
if not useRatchetingSL and useTrailingSL and useStopLoss and strategy.position_size != 0
    if strategy.position_size > 0 and buySignal and strategy.position_size[1] > 0
        new_sl = low - stopLossOffset
        currentLongSL := new_sl
        strategy.exit("Main Long SL", "Long", stop=new_sl)
    
    if strategy.position_size < 0 and sellSignal and strategy.position_size[1] < 0
        new_sl = high + stopLossOffset
        currentShortSL := new_sl
        strategy.exit("Main Short SL", "Short", stop=new_sl)

// Ratcheting SL updates (active additional exit with priority, only if better, on signals after entry)
if useRatchetingSL and strategy.position_size != 0
    if strategy.position_size > 0 and buySignal and strategy.position_size[1] > 0
        new_rat_sl = low - stopLossOffset
        if na(currentRatchetingLongSL) or new_rat_sl > currentRatchetingLongSL
            currentRatchetingLongSL := new_rat_sl
            strategy.exit("Ratcheting Long SL", "Long", stop=new_rat_sl)
    
    if strategy.position_size < 0 and sellSignal and strategy.position_size[1] < 0
        new_rat_sl = high + stopLossOffset
        if na(currentRatchetingShortSL) or new_rat_sl < currentRatchetingShortSL
            currentRatchetingShortSL := new_rat_sl
            strategy.exit("Ratcheting Short SL", "Short", stop=new_rat_sl)

// Exit conditions based on Additional MAs
longExitMA = (useMA1Filter and close < ma1) or (useMA2Filter and close < ma2)
shortExitMA = (useMA1Filter and close > ma1) or (useMA2Filter and close > ma2)
if longExitMA
    strategy.close("Long", comment="MA Exit Long")
if shortExitMA
    strategy.close("Short", comment="MA Exit Short")

// Plot signals as triangles for visualization (all signals, for reference)
plotshape(series=buySignal, title="Buy Signal", location=location.belowbar, color=color.yellow, style=shape.triangleup, size=size.small)
plotshape(series=sellSignal, title="Sell Signal", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)

// Continuous visual SL lines limited to current trade (na when no position or after close)
longMainSL = useStopLoss and not useRatchetingSL and strategy.position_size > 0 ? currentLongSL : na
shortMainSL = useStopLoss and not useRatchetingSL and strategy.position_size < 0 ? currentShortSL : na
longRatSL = useRatchetingSL and strategy.position_size > 0 ? currentRatchetingLongSL : na
shortRatSL = useRatchetingSL and strategy.position_size < 0 ? currentRatchetingShortSL : na

plot(longMainSL, color=color.red, title="Long SL (Main)", style=plot.style_stepline, linewidth=2)
plot(shortMainSL, color=color.red, title="Short SL (Main)", style=plot.style_stepline, linewidth=2)
plot(longRatSL, color=color.orange, title="Long Ratcheting SL (Priority Exit)", style=plot.style_stepline, linewidth=2)
plot(shortRatSL, color=color.orange, title="Short Ratcheting SL (Priority Exit)", style=plot.style_stepline, linewidth=2)

// Background color based on position
bgcolor(strategy.position_size > 0 ? color.new(color.green, 90) : strategy.position_size < 0 ? color.new(color.red, 90) : color.new(color.gray, 95))
