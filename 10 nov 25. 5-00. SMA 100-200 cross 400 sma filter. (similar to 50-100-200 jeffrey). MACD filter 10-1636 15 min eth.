//@version=5
strategy("50-200 SMA Cross Strategy with Passive 100 & Filter MA + MACD", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// Fast MA Inputs
type_fast = input.string("SMA", "Fast MA Type", options=["SMA", "EMA", "WMA", "RMA", "DEMA", "TEMA", "TMA", "VWMA", "HMA"], group="Fast MA (50) Settings")
src_fast = input.source(close, "Fast MA Source", group="Fast MA (50) Settings")
fast_len = input.int(50, "Fast MA Length", minval=1, group="Fast MA (50) Settings")

// Passive MA Inputs
type_passive = input.string("SMA", "Passive MA Type", options=["SMA", "EMA", "WMA", "RMA", "DEMA", "TEMA", "TMA", "VWMA", "HMA"], group="Passive MA (100) Settings")
src_passive = input.source(close, "Passive MA Source", group="Passive MA (100) Settings")
mid_len = input.int(100, "Passive MA Length", minval=1, group="Passive MA (100) Settings")

// Slow MA Inputs
type_slow = input.string("SMA", "Slow MA Type", options=["SMA", "EMA", "WMA", "RMA", "DEMA", "TEMA", "TMA", "VWMA", "HMA"], group="Slow MA (200) Settings")
src_slow = input.source(close, "Slow MA Source", group="Slow MA (200) Settings")
slow_len = input.int(200, "Slow MA Length", minval=1, group="Slow MA (200) Settings")

// Filter MA Inputs
type_filter = input.string("SMA", "Filter MA Type", options=["SMA", "EMA", "WMA", "RMA", "DEMA", "TEMA", "TMA", "VWMA", "HMA"], group="Filter MA Settings")
src_filter = input.source(close, "Filter MA Source", group="Filter MA Settings")
filter_len = input.int(150, "Filter MA Length", minval=1, group="Filter MA Settings")

// === MACD Inputs ===
useMACD1 = input.bool(true, "Use MACD J1 Filter", group="MACD Filter Settings")
useMACD2 = input.bool(true, "Use MACD S1 Filter", group="MACD Filter Settings")
useMACD3 = input.bool(true, "Use MACD S2 Filter", group="MACD Filter Settings")
fast_j  = input.int(12, "MACD J1 Fast", group="MACD Filter Settings")
slow_j  = input.int(26, "MACD J1 Slow", group="MACD Filter Settings")
fast_s1 = input.int(24, "MACD S1 Fast", group="MACD Filter Settings")
slow_s1 = input.int(52, "MACD S1 Slow", group="MACD Filter Settings")
fast_s2 = input.int(30, "MACD S2 Fast", group="MACD Filter Settings")
slow_s2 = input.int(65, "MACD S2 Slow", group="MACD Filter Settings")

// Strategy Settings
bypass_filter_logic = input.bool(false, "Bypass MA Filter Logic (Reversal Only)", group="Strategy Settings")
bypass_filter_exits = input.bool(false, "Bypass Filter MA Exits (Exits Only on 50-200 Cross)", group="Strategy Settings")
use_macd_entries = input.bool(true, "Use MACD for Additional Entries", group="Strategy Settings")
use_macd_exits = input.bool(true, "Use MACD for Additional Exits", group="Strategy Settings")

// === Functions ===
alpha(len) => 2 / (len + 1)
macd_level(level, price, fast_len, slow_len) =>
    (level + (1 - alpha(slow_len)) * ta.ema(price, slow_len)[1] - (1 - alpha(fast_len)) * ta.ema(price, fast_len)[1]) / (alpha(fast_len) - alpha(slow_len))

// Custom DEMA function
dema(src, len) =>
    ema1 = ta.ema(src, len)
    2 * ema1 - ta.ema(ema1, len)

// Custom TEMA function
tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    3 * (ema1 - ema2) + ema3

// Function to calculate MA based on type
get_ma(typ, len, s) =>
    switch typ
        "SMA" => ta.sma(s, len)
        "EMA" => ta.ema(s, len)
        "WMA" => ta.wma(s, len)
        "RMA" => ta.rma(s, len)
        "DEMA" => dema(s, len)
        "TEMA" => tema(s, len)
        "VWMA" => ta.vwma(s, len)
        "HMA" => ta.hma(s, len)
        "TMA" => 
            tma_len = math.round(len / 2.0)
            ta.sma(ta.sma(s, tma_len), tma_len)
        => na

// Calculate MAs
fast_ma = get_ma(type_fast, fast_len, src_fast)
passive_ma = get_ma(type_passive, mid_len, src_passive)
slow_ma = get_ma(type_slow, slow_len, src_slow)
filter_ma = get_ma(type_filter, filter_len, src_filter)

// === MACD Zero Lines (3 штуки) ===
macd_j1   = macd_level(0, close, fast_j, slow_j)
macd_s1_1 = macd_level(0, close, fast_s1, slow_s1)
macd_s2_1 = macd_level(0, close, fast_s2, slow_s2)

// === MACD Filters ===
macdUp1   = close > macd_j1
macdDown1 = close < macd_j1
macdUp2   = close > macd_s1_1
macdDown2 = close < macd_s1_1
macdUp3   = close > macd_s2_1
macdDown3 = close < macd_s2_1

macd_filter_up   = (not useMACD1 or macdUp1) and (not useMACD2 or macdUp2) and (not useMACD3 or macdUp3)
macd_filter_down = (not useMACD1 or macdDown1) and (not useMACD2 or macdDown2) and (not useMACD3 or macdDown3)

// Plot MAs
plot(fast_ma, "Fast MA", color=color.blue, linewidth=2)
plot(passive_ma, "Passive MA (100)", color=color.orange, linewidth=1)  // Passive: just for reference, not used in signals
plot(slow_ma, "Slow MA", color=color.red, linewidth=2)
plot(filter_ma, "Filter MA", color=color.purple, linewidth=2)  // Filter: directional bias

// Plot MACD Lines (enhanced visibility: brighter colors, thicker lines, and style=plot.style_linebr for breaks if na)
p1 = plot(useMACD1 ? macd_j1 : na, "MACD J1 Zero Line", color=color.new(color.red, 0), linewidth=3, style=plot.style_line)
p2 = plot(useMACD2 ? macd_s1_1 : na, "MACD S1 Zero Line", color=color.new(color.green, 0), linewidth=3, style=plot.style_line)
p3 = plot(useMACD3 ? macd_s2_1 : na, "MACD S2 Zero Line", color=color.new(color.blue, 0), linewidth=3, style=plot.style_line)

// Add fill between lines for better visibility if all enabled
fill(p1, p2, color=color.new(color.yellow, 90), title="MACD Fill 1-2")
fill(p2, p3, color=color.new(color.orange, 90), title="MACD Fill 2-3")

// Signal definitions
long_signal = ta.crossover(fast_ma, slow_ma)
short_signal = ta.crossunder(fast_ma, slow_ma)
long_filter = close > filter_ma
short_filter = close < filter_ma
filter_long_cross = ta.crossover(close, filter_ma)
filter_short_cross = ta.crossunder(close, filter_ma)
bullish_regime = fast_ma > slow_ma
bearish_regime = fast_ma < slow_ma

// MACD cross signals
macd_long_cross = macd_filter_up and not macd_filter_up[1]
macd_short_cross = macd_filter_down and not macd_filter_down[1]

// Handle cross signals: Exit opposite on cross (always active for reversals)
if long_signal
    if strategy.position_size < 0
        strategy.close("Short", comment="Cross Exit Short")
if short_signal
    if strategy.position_size > 0
        strategy.close("Long", comment="Cross Exit Long")

// Entries on cross (always for reversals, with filter only if not bypassed, plus MACD filter)
long_entry_cond = long_signal and (bypass_filter_logic or long_filter) and macd_filter_up
if long_entry_cond
    strategy.entry("Long", strategy.long, comment="Cross + Filter + MACD Long")

short_entry_cond = short_signal and (bypass_filter_logic or short_filter) and macd_filter_down
if short_entry_cond
    strategy.entry("Short", strategy.short, comment="Cross + Filter + MACD Short")

// Additional entries on filter cross when regime already set (only if not bypassed, plus MACD filter)
if not bypass_filter_logic
    if filter_long_cross and bullish_regime and macd_filter_up
        strategy.entry("Long", strategy.long, comment="Filter Cross + MACD Long")
    if filter_short_cross and bearish_regime and macd_filter_down
        strategy.entry("Short", strategy.short, comment="Filter Cross + MACD Short")

// Additional entries on MACD cross when regime already set (if enabled)
if use_macd_entries
    if macd_long_cross and bullish_regime
        strategy.entry("Long", strategy.long, comment="MACD Cross Long")
    if macd_short_cross and bearish_regime
        strategy.entry("Short", strategy.short, comment="MACD Cross Short")

// Additional exits on filter breach (only if not bypassed and not bypass_filter_exits)
if not bypass_filter_logic
    if strategy.position_size > 0 and not long_filter and not bypass_filter_exits
        strategy.close("Long", comment="Filter Breach Exit Long")
    if strategy.position_size < 0 and not short_filter and not bypass_filter_exits
        strategy.close("Short", comment="Filter Breach Exit Short")

// Additional exits on MACD breach (if enabled)
if use_macd_exits
    if strategy.position_size > 0 and not macd_filter_up
        strategy.close("Long", comment="MACD Breach Exit Long")
    if strategy.position_size < 0 and not macd_filter_down
        strategy.close("Short", comment="MACD Breach Exit Short")
